---
title: Piping Input to Forge
sidebar_position: 7
description: "Learn how to pipe command output and file content directly to Forge for seamless workflow integration."
sidebar_label: Piping Input
---

# Piping Input to Forge

Forge supports reading input from stdin (standard input) via piping, allowing you to pass content from other commands or files directly to Forge.

## Basic Usage

Pipe content from any command or file directly to Forge:

```bash
# Pipe from a file
cat prompt.txt | forge

# Pipe from echo
echo "Explain what this project does" | forge

# Pipe from git commands
git log --oneline -10 | forge

# Pipe from other tools
tail -n 100 error.log | forge
ls -la | forge
cargo test 2>&1 | forge
```

## How It Works

When you pipe content to Forge:

1. **Detects Piped Input**: Automatically recognizes stdin from a pipe
2. **Reads and Processes**: Reads all content until EOF, trims whitespace, and uses it as your prompt

## Critical Behavior

### Empty Input Causes Hanging

:::danger Always Check for Empty Output
Empty piped content causes Forge to wait indefinitely for interactive input because it can't distinguish between "no input yet" and "no input ever."

**Problem commands:**
```bash
# These HANG if they produce no output
git diff | forge                    # No changes = hangs
grep "pattern" file.txt | forge     # No matches = hangs
find . -name "*.xyz" | forge        # No files found = hangs
```

**Solution 1 - Check before piping:**
```bash
# For git diff
if ! git diff --quiet; then
    git diff | forge
fi

# For grep
if grep -q "pattern" file.txt; then
    grep "pattern" file.txt | forge
fi
```

**Solution 2 - Provide fallback content:**
```bash
(git diff || echo "No changes detected") | forge
```

**Solution 3 - Include instructions in pipe:**
```bash
# Instructions ensure content is always present
{
  echo "Review these changes if any exist:"
  echo ""
  git diff
} | forge
```
:::

### --prompt Flag Takes Precedence

:::warning Cannot Combine Piping with --prompt
The `--prompt` flag will **completely ignore** piped content:

```bash
# The piped content is IGNORED
echo "This is ignored" | forge --prompt "This is used"
```

Choose one input method or the other.
:::

### Works with Other Flags

Piping works with all other Forge flags:

```bash
echo "Review this code" | forge --verbose --restricted
echo "Quick task" | forge --agent muse
git log -5 | forge --model claude-sonnet-4
```

## Practical Examples

### Code Review Workflow

```bash
# Check for changes first
if ! git diff --quiet; then
    git diff | forge
fi

# Review staged changes
if ! git diff --cached --quiet; then
    git diff --cached | forge
fi

# Combine instructions with diff
{
  echo "Review these changes for security issues:"
  echo ""
  git diff
} | forge
```

### Log Analysis

```bash
# Analyze recent errors
tail -n 50 application.log | forge

# Add context to piped content
{
  echo "Summarize these test failures:"
  echo ""
  cargo test 2>&1
} | forge

# Review build output
{
  echo "Identify build issues:"
  echo ""
  npm run build 2>&1
} | forge
```

### File Content Review

```bash
# Review a specific file
cat src/main.rs | forge

# Review with instructions
{
  echo "Review this code for best practices:"
  echo ""
  cat src/database.js
} | forge

# Review multiple files
{
  echo "Analyze these Rust files:"
  echo ""
  cat src/*.rs
} | forge
```

### Command Output Analysis

```bash
# Analyze directory structure
{
  echo "Explain this directory structure:"
  echo ""
  ls -la
} | forge

# Process find results
{
  echo "Review all TypeScript files:"
  echo ""
  find . -name "*.ts" -exec cat {} \;
} | forge

# Clipboard to Forge (macOS)
pbpaste | forge

# Clipboard to Forge (Linux with xclip)
xclip -selection clipboard -o | forge
```

## Advanced Patterns

### Reusable Prompt Templates

```bash
# Create a template
cat > review-template.txt << 'EOF'
Please review this code for:
- Security vulnerabilities
- Performance issues
- Code style and best practices

Code to review:
EOF

# Use it with piped content
cat review-template.txt <(git diff) | forge
```

### Conditional Piping

```bash
# Check file size before piping
[ -s file.txt ] && cat file.txt | forge

# Check command success
git diff --quiet || git diff | forge
```

### Multi-Source Input

```bash
# Combine multiple sources
{
  echo "=== Current Changes ==="
  git diff
  echo ""
  echo "=== Recent Commits ==="
  git log --oneline -5
  echo ""
  echo "Please summarize recent development activity"
} | forge
```

## Quick Reference

**Safe patterns:**
```bash
echo "text" | forge
{ echo "Instructions:"; command; } | forge
(command || echo "fallback") | forge
```

**Unsafe (will hang on empty output):**
```bash
git diff | forge
grep "pattern" file.txt | forge
```

## Tips

1. **Always Verify Output**: Commands like `git diff`, `grep`, or `find` might return nothing. Check before piping to avoid hanging.
2. **Don't Mix Input Methods**: The `--prompt` flag ignores piped content. Use one or the other.
3. **Mind Large Files**: Piped content is read entirely into memory.
4. **Capture Errors**: Use `2>&1` to capture both stdout and stderr.
5. **Add Context**: Include instructions within piped content for better results.

## Implementation Details

:::info Technical Background
The piping feature uses the `atty` crate to detect non-TTY stdin:

```rust
// Check if there's piped input and no explicit prompt was provided
if cli.prompt.is_none() && !atty::is(atty::Stream::Stdin) {
    let mut stdin_content = String::new();
    std::io::stdin().read_to_string(&mut stdin_content)?;
    let trimmed_content = stdin_content.trim();
    if !trimmed_content.is_empty() {
        cli.prompt = Some(trimmed_content.to_string());
    }
}
```

This approach can't distinguish between "no input yet" and "no input ever," which is why empty piped content causes indefinite waiting.
:::
